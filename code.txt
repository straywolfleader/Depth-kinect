#include <Windows.h>  
#include <Kinect.h> 
#include <opencv2/opencv.hpp>  
#include <cstdlib>  

using namespace std;
using namespace cv;


//释放接口需要自己定义  
template<class Interface>
inline void SafeRelease(Interface *& pInterfaceToRelease)
{
	if (pInterfaceToRelease != NULL) {
		pInterfaceToRelease->Release();
		pInterfaceToRelease = NULL;
	}
}

int main(int argc, char **argv[])
{
	//OpenCV中开启CPU的硬件指令优化功能函数  
	setUseOptimized(true);

	// 打开kinect  
	IKinectSensor* pSensor;
	HRESULT hResult = S_OK;
	hResult = GetDefaultKinectSensor(&pSensor);
	if (FAILED(hResult)) {
		cerr << "Error : GetDefaultKinectSensor" << std::endl;
		return -1;
	}

	hResult = pSensor->Open();
	if (FAILED(hResult)) {
		cerr << "Error : IKinectSensor::Open()" << std::endl;
		return -1;
	}

	// 深度帧源  
	IDepthFrameSource* pDepthSource;
	hResult = pSensor->get_DepthFrameSource(&pDepthSource);
	if (FAILED(hResult)) {
		cerr << "Error : IKinectSensor::get_DepthFrameSource()" << std::endl;
		return -1;
	}

	// 深度帧读取  
	IDepthFrameReader* pDepthReader;
	hResult = pDepthSource->OpenReader(&pDepthReader);
	if (FAILED(hResult)) {
		cerr << "Error : IDepthFrameSource::OpenReader()" << std::endl;
		return -1;
	}

	// Description  
	IFrameDescription* pDescription;
	hResult = pDepthSource->get_FrameDescription(&pDescription);
	if (FAILED(hResult)) {
		cerr << "Error : IDepthFrameSource::get_FrameDescription()" << std::endl;
		return -1;
	}

	int width = 0;
	int height = 0;
	pDescription->get_Width(&width); // 512  
	pDescription->get_Height(&height); // 424  
	unsigned int bufferSize = width * height * sizeof(unsigned short);

	// Range  
	unsigned short min = 0;
	unsigned short max = 0;
	pDepthSource->get_DepthMinReliableDistance(&min); // 500  
	pDepthSource->get_DepthMaxReliableDistance(&max); // 4500  
	cout << "Range : " << min << " - " << max << std::endl;

	//创建尺寸为height x width 的1通道8位图像  
	Mat bufferMat(height, width, CV_16UC1);
	Mat depthMat(height, width, CV_8UC1);

	while (1) {
		// 更新深度帧  
		IDepthFrame* pDepthFrame = nullptr;
		hResult = pDepthReader->AcquireLatestFrame(&pDepthFrame);
		if (SUCCEEDED(hResult)) {
			hResult = pDepthFrame->AccessUnderlyingBuffer(&bufferSize, reinterpret_cast<UINT16**>(&bufferMat.data));
			if (SUCCEEDED(hResult)) {
				bufferMat.convertTo(depthMat, CV_8U, -255.0f / 4500.0f, 255.0f);
			}
		}
		SafeRelease(pDepthFrame);

		imshow("Depth", depthMat);

		if (cv::waitKey(30) == VK_ESCAPE) {
			break;
		}
	}

	SafeRelease(pDepthSource);
	SafeRelease(pDepthReader);
	SafeRelease(pDescription);
	if (pSensor) {
		pSensor->Close();
	}
	SafeRelease(pSensor);

	return 0;
}